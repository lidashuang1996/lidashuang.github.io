<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="LiDaShuang">





<title>Netty高性能之道 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">LiDaShuang</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">列表</a>
                
                    <a class="menu-item" href="/category">类别</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">LiDaShuang</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">列表</a>
                
                    <a class="menu-item" href="/category">类别</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Netty高性能之道</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">LiDaShuang</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">四月 19, 2020&nbsp;&nbsp;9:25:15</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><h3 id="1-Netty-惊人的性能数据"><a href="#1-Netty-惊人的性能数据" class="headerlink" title="1. Netty 惊人的性能数据"></a>1. Netty 惊人的性能数据</h3><p>通过使用 Netty（NIO 框架）相比于传统基于 Java 序列化 +BIO（同步阻塞 IO）的通信框架，性能提升了 8 倍多。事实上，我对这个数据并不感到惊讶，根据我多的 NIO 编程经验，通过选择合适的 NIO 框架，精心的设计 Reactor 线程模型，达到上述性能指标是完全有可能的。</p>
<h3 id="2-传统-RPC-调用性能差的三宗罪"><a href="#2-传统-RPC-调用性能差的三宗罪" class="headerlink" title="2. 传统 RPC 调用性能差的三宗罪"></a>2. 传统 RPC 调用性能差的三宗罪</h3><p>网络传输方式问题：传统的 RPC 框架或者基于 RMI 等方式的远程服务（过程）调用采用了同步阻塞 IO，当客户端的 并发压力或者网络时延增大之后，同步阻塞 IO 会由于频繁的 wait 导致 IO 线程经常性的阻塞，由于线程无法高效的工作，IO 处理能力自然下降。下面，我们通过 BIO 通信模型图看下 BIO 通信的弊端：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419093010575.png" alt="image-20200419093010575"></p>
<p>采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，接收到客户端连接之后为客户端连接创建一个新的线程处理请求消息，处理完成之后，返回应答消息给客户端，线程销毁，这就是典型的一请求一应答模型。该架构最大的问题就是不具备弹性伸缩能力，当并发访问量增加后，服务端的线程个数和并发访问数成线性正比，由于线程是 JAVA 虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能急剧下降，随着并发量的继续增加，可能会发生句柄溢出、线程堆栈溢出等问题，并导致服务器最终宕机。 </p>
<p>序列化方式问题：Java 序列化存在如下几个典型问题：</p>
<ol>
<li><p>Java 序列化机制是 Java 内部的一种对象编解码技术，无法跨语言使用；</p>
<p>例如对于异构系统之间的对接，Java 序列化后的码流需要能够通过其它语言反序列化成原始对象（副本），目前很难支持；</p>
</li>
<li><p>相比于其它开源的序列化框架，Java 序列化后的码流太大，无论是网络传输还是持久化到磁盘，都会导致额外的资源占用；</p>
</li>
<li><p>序列化性能差（CPU 资源占用高）。 </p>
</li>
</ol>
<p>线程模型问题：由于采用同步阻塞 IO，这会导致每个 TCP 连接都占用 1 个线程，由于线程资源是JVM 虚拟机非常宝贵的资源，当 IO 读写阻塞导致线程无法及时释放时，会导致系统性能急剧下降，严重的甚至会导致虚拟机无法创建新的线程。</p>
<h3 id="3-高性能的三个主题"><a href="#3-高性能的三个主题" class="headerlink" title="3. 高性能的三个主题"></a>3. 高性能的三个主题</h3><ol>
<li>传输：用什么样的通道将数据发送给对方，BIO、NIO 或者 AIO，IO 模型在很大程度上决定了框架的性能。 </li>
<li>协议：采用什么样的通信协议，HTTP 或者内部私有协议。协议的选择不同，性能模型也不同。相比于公有协议， 内部私有协议的性能通常可以被设计的更优。 </li>
<li>线程：数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，Reactor 线程模型的不同， 对性能的影响也非常大。</li>
</ol>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419093614264.png" alt="image-20200419093614264"></p>
<h2 id="2-Netty-高性能之道"><a href="#2-Netty-高性能之道" class="headerlink" title="2. Netty 高性能之道"></a>2. Netty 高性能之道</h2><h3 id="1-异步非阻塞通信"><a href="#1-异步非阻塞通信" class="headerlink" title="1. 异步非阻塞通信"></a>1. 异步非阻塞通信</h3><p>在 IO 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者 IO 多路复用技术进行处理。IO 多路复用技术通过把多个 IO 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。 JDK1.4 提供了对非阻塞 IO（NIO）的支持，JDK1.5_update10 版本使用 epoll 替代了传统的 select/poll，极大的提升了 NIO 通信的性能。</p>
<p>JDK NIO 通信模型如下所示：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419094353787.png" alt="image-20200419094353787"></p>
<p>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现。这两种新增的通道都支持阻塞和非阻塞两种模式。阻塞模式使用非常简单，但是性能和可靠性都不好，非阻塞模式正好相反。开发人员一般可以根据自己的需要来选择合适的模式，一般来说，低负载、低并发的应用程序可以选择同步阻塞 IO 以降低编程复杂度。但是对于高负载、高并发的网络应用，需要使用 NIO 的非阻塞模式进行开发。 </p>
<p>Netty 架构按照 Reactor 模式设计和实现，它的服务端通信序列图如下：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419094530329.png" alt="image-20200419094530329"></p>
<p>客户端通信序列图如下：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419094639458.png" alt="image-20200419094639458"></p>
<p>Netty 的 IO 线程 NioEventLoop 聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端 Channel，由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 IO 阻塞导致的线程挂起。另外，由于 Netty 采用了异步通信模式，一个 IO 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 IO 一 连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p>
<h3 id="2-零拷贝"><a href="#2-零拷贝" class="headerlink" title="2. 零拷贝"></a>2. 零拷贝</h3><p>Netty 的 “零拷贝” 主要体现在如下三个方面： </p>
<ol>
<li>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li>
<li>Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</li>
<li>Netty 的文件传输采用了 transferTo()方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write() 方式导致的内存拷贝问题。 </li>
</ol>
<p>下面，我们对上述三种“零拷贝”进行说明，先看 Netty 接收 Buffer 的创建： 打开 AbstractNioByteChannel$NioByteUnsafe</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.channel.nio;</span><br><span class="line"><span class="comment">// AbstractNioByteChannel.NioByteUnsafe.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// DefaultMaxBytesRecvByteBufAllocator.class 的 allocate 方法</span></span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// nothing was read. release the buffer.</span></span><br><span class="line">                byteBuf.release();</span><br><span class="line">                byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Check if there is a readPending which was not processed yet.</span></span><br><span class="line">        <span class="comment">// This could be for two reasons:</span></span><br><span class="line">        <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span></span><br><span class="line">        <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/2254</span></span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultMaxBytesRecvByteBufAllocator.class</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">allocate</span><span class="params">(ByteBufAllocator alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> alloc.ioBuffer(guess());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于是每次循环读取一次消息，就通过 ByteBufferAllocator </span></span><br><span class="line"><span class="comment">// 的 ioBuffer 方法获取 ByteBuf 对象，下面继续看它的接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuf</span> <span class="keyword">implements</span> <span class="title">ReferenceCounted</span>, <span class="title">Comparable</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当进行 Socket IO 读写的时候，为了避免从堆内存拷贝一份副本到直接内存</span></span><br><span class="line"><span class="comment">// Netty 的 ByteBuf 分配器直接创建非堆内存</span></span><br><span class="line"><span class="comment">// 避免缓冲区的二次拷贝，通过“零拷贝”来提升读写性能。</span></span><br></pre></td></tr></table></figure>



<p>下面我们继续看第二种“零拷贝”的实现 CompositeByteBuf，它对外将多个 ByteBuf 封装成一个 ByteBuf，对外提供统一封装后的 ByteBuf 接口，它的类定义如下：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419101014053.png" alt="image-20200419101014053"></p>
<p>通过继承关系我们可以看出 CompositeByteBuf 实际就是个 ByteBuf 的包装器，它将多个 ByteBuf 组合成一个集合，然后对外提供统一的 ByteBuf 接口，相关定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuffer EMPTY_NIO_BUFFER = Unpooled.EMPTY_BUFFER.nioBuffer();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Iterator&lt;ByteBuf&gt; EMPTY_ITERATOR = Collections.&lt;ByteBuf&gt;emptyList().iterator();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBufAllocator alloc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> direct;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Precondition is that &#123;<span class="doctag">@code</span> buffer != null&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">addComponent0</span><span class="params">(<span class="keyword">boolean</span> increaseWriterIndex, <span class="keyword">int</span> cIndex, ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> buffer != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkComponentIndex(cIndex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> readableBytes = buffer.readableBytes();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// No need to consolidate - just add a component to the list.</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">            Component c = <span class="keyword">new</span> Component(buffer.order(ByteOrder.BIG_ENDIAN).slice());</span><br><span class="line">            <span class="keyword">if</span> (cIndex == components.size()) &#123;</span><br><span class="line">                wasAdded = components.add(c);</span><br><span class="line">                <span class="keyword">if</span> (cIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                    c.endOffset = readableBytes;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Component prev = components.get(cIndex - <span class="number">1</span>);</span><br><span class="line">                    c.offset = prev.endOffset;</span><br><span class="line">                    c.endOffset = c.offset + readableBytes;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                components.add(cIndex, c);</span><br><span class="line">                wasAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (readableBytes != <span class="number">0</span>) &#123;</span><br><span class="line">                    updateComponentOffsets(cIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (increaseWriterIndex) &#123;</span><br><span class="line">                writerIndex(writerIndex() + buffer.readableBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cIndex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wasAdded) &#123;</span><br><span class="line">                buffer.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们看下文件传输的“零拷贝”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(WritableByteChannel target, <span class="keyword">long</span> position)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="keyword">this</span>.count - position;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span> || position &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"position out of range: "</span> + position +</span><br><span class="line">            <span class="string">" (expected: 0 - "</span> + (<span class="keyword">this</span>.count - <span class="number">1</span>) + <span class="string">')'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (refCnt() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Call open to make sure fc is initialized. This is a no-oop if we called it before.</span></span><br><span class="line">    open();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> written = file.transferTo(<span class="keyword">this</span>.position + position, count, target);</span><br><span class="line">    <span class="keyword">if</span> (written &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        transferred += written;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty 文件传输 DefaultFileRegion 通过 transferTo() 方法将文件发送到目标 Channel 中，下面重点看 FileChannel 的 transferTo() 方法，它的 API DOC 说明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transfers bytes from this channel's file to the given writable byte</span></span><br><span class="line"><span class="comment">* channel.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; An attempt is made to read up to &lt;tt&gt;count&lt;/tt&gt; bytes starting at</span></span><br><span class="line"><span class="comment">* the given &lt;tt&gt;position&lt;/tt&gt; in this channel's file and write them to the</span></span><br><span class="line"><span class="comment">* target channel. An invocation of this method may or may not transfer</span></span><br><span class="line"><span class="comment">* all of the requested bytes; whether or not it does so depends upon the</span></span><br><span class="line"><span class="comment">* natures and states of the channels. Fewer than the requested number of</span></span><br><span class="line"><span class="comment">* bytes are transferred if this channel's file contains fewer than</span></span><br><span class="line"><span class="comment">* &lt;tt&gt;count&lt;/tt&gt; bytes starting at the given &lt;tt&gt;position&lt;/tt&gt;, or if the</span></span><br><span class="line"><span class="comment">* target channel is non-blocking and it has fewer than &lt;tt&gt;count&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">* bytes free in its output buffer.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; This method does not modify this channel's position. If the given</span></span><br><span class="line"><span class="comment">* position is greater than the file's current size then no bytes are</span></span><br><span class="line"><span class="comment">* transferred. If the target channel has a position then bytes are</span></span><br><span class="line"><span class="comment">* written starting at that position and then the position is incremented</span></span><br><span class="line"><span class="comment">* by the number of bytes written.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; This method is potentially much more efficient than a simple loop</span></span><br><span class="line"><span class="comment">* that reads from this channel and writes to the target channel. Many</span></span><br><span class="line"><span class="comment">* operating systems can transfer bytes directly from the filesystem cache</span></span><br><span class="line"><span class="comment">* to the target channel without actually copying them. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count,WritableByteChannel target)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>对于很多操作系统它直接将文件缓冲区的内容发送到目标 Channel 中，而不需要通过拷贝的方式，这是一种更加高效的传输方式，它实现了文件传输的“零拷贝”。</p>
<h3 id="3-内存池"><a href="#3-内存池" class="headerlink" title="3. 内存池"></a>3. 内存池</h3><p>随着 JVM 虚拟机和 JIT 即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区 Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。下面我们一起看下 Netty ByteBuf 的实现：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419095321696.png" alt="image-20200419095321696"></p>
<p>Netty 提供了多种内存管理策略，通过在启动辅助类中配置相关参数，可以实现差异化的定制。 </p>
<p>下面通过性能测试，我们看下基于内存池循环利用的 ByteBuf 和普通 ByteBuf 的性能差异。 </p>
<p><strong>用例一，使用内存池分配器创建直接内存缓冲区：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] CONTENT = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> loop = <span class="number">1800000</span>;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">ByteBuf poolBuffer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">    poolBuffer = PooledByteBufAllocator.DEFAULT.directBuffer(<span class="number">1024</span>);</span><br><span class="line">    poolBuffer.writeBytes(CONTENT);</span><br><span class="line">    poolBuffer.release();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"内存池分配缓冲区耗时"</span> + (endTime - startTime) + <span class="string">"ms."</span>);</span><br></pre></td></tr></table></figure>

<p><strong>用例二，使用非堆内存分配器创建的直接内存缓冲区：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> startTime2 = System.currentTimeMillis();</span><br><span class="line">ByteBuf buffer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">buffer = Unpooled.directBuffer(<span class="number">1024</span>);</span><br><span class="line">    buffer.writeBytes(CONTENT);</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"非内存池分配缓冲区耗时"</span> + (endTime - startTime2) + <span class="string">"ms."</span>);</span><br></pre></td></tr></table></figure>

<p>性能测试经验表明，采用内存池的 ByteBuf 相比于朝生夕灭的 ByteBuf，性能高。（性能数据与使用场景强相</p>
<p>下面我们一起简单分析下 Netty 内存池的内存分配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PooledByteBufAllocator.DEFAULT.directBuffer(1024)</span></span><br><span class="line"><span class="comment">// directBuffer() 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span> &amp;&amp; maxCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(initialCapacity, maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> newDirectBuffer(initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractByteBufAllocator</span> <span class="keyword">implements</span> <span class="title">ByteBufAllocator</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a direct &#123;<span class="doctag">@link</span> ByteBuf&#125; with the given initialCapacity and maxCapacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> 	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419110127185.png" alt="image-20200419110127185"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PooledByteBufAllocator.class</span></span><br><span class="line"><span class="comment">// 代码跳转到 PooledByteBufAllocator 的 newDirectBuffer 方法</span></span><br><span class="line"><span class="comment">// 从 Cache 中获取内存区域 PoolArena，调用它的 allocate</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PoolThreadCache cache = threadCache.get();</span><br><span class="line">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">    ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 查看里面详细信息</span></span><br><span class="line">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">            buf = UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf = <span class="keyword">new</span> UnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PoolArena 的 allocate 方法如下：</span></span><br><span class="line"><span class="function">PooledByteBuf&lt;T&gt; <span class="title">allocate</span><span class="params">(PoolThreadCache cache, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledByteBuf&lt;T&gt; buf = newByteBuf(maxCapacity);</span><br><span class="line">    allocate(cache, buf, reqCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点分析 newByteBuf 的实现，它同样是个抽象方法，由子类 DirectArena 和 HeapArena 来实现不同类型的缓冲区分配，由于测试用例使用的是堆外内存，</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419110405399.png" alt="image-20200419110405399"></p>
<p>因此重点分析 DirectArena 的实现：如果没有开启使用 sun 的 unsafe，则 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DirectArena.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PooledByteBuf&lt;ByteBuffer&gt; <span class="title">newByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (HAS_UNSAFE) &#123;</span><br><span class="line">        <span class="keyword">return</span> PooledUnsafeDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PooledDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 PooledDirectByteBuf 的 newInstance 方法，代码如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PooledDirectByteBuf.class</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PooledDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">    buf.reuse(maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 RECYCLER 的 get 方法循环使用 ByteBuf 对象，如果是非内存池实现，则直接创建一个新的 ByteBuf 对象。从缓冲池中获取 ByteBuf 之后，调用 AbstractReferenceCountedByteBuf 的 setRefCnt 方法设置引用计数器，用于对象的引用计数和内存回收（类似 JVM 垃圾回收机制）。</p>
<h3 id="4-高效的-Reactor-线程模型"><a href="#4-高效的-Reactor-线程模型" class="headerlink" title="4. 高效的 Reactor 线程模型"></a>4. 高效的 Reactor 线程模型</h3><p>常用的 Reactor 线程模型有三种，分别如下： </p>
<ol>
<li>Reactor 单线程模型；</li>
<li>Reactor 多线程模型；</li>
<li>主从 Reactor 多线程模型；</li>
</ol>
<p>Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程的职责如下：</p>
<ol>
<li>作为 NIO 服务端，接收客户端的 TCP 连接；</li>
<li>作为 NIO 客户端，向服务端发起 TCP 连接；</li>
<li>读取通信对端的请求或者应答消息；</li>
<li>向通信对端发送消息请求或者应答消息；</li>
</ol>
<p>Reactor 单线程模型示意图如下所示：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419111026372.png" alt="image-20200419111026372"></p>
<p>由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独立处理所有 IO 相 关的操作。从架构层面看，一个 NIO 线程确实可以完成其承担的职责。例如，通过 Acceptor 接收客户端的 TCP 连接 请求消息，链路建立成功之后，通过 Dispatch 将对应的 ByteBuffer 派发到指定的 Handler 上进行消息解码。用户 Handler 可以通过 NIO 线程将消息发送给客户端。 对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发的应用却不合适，主要原因如下： </p>
<ol>
<li>一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，即便 NIO 线程的 CPU 负荷达到 100%，也无法满足海量消息的编码、解码、读取和发送；</li>
<li>当 NIO 线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了 NIO 线程的负载，最终会导致大量消息积压和处理超时，NIO 线程会成为系统的性能瓶颈；</li>
<li>可靠性问题：一旦 NIO 线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</li>
</ol>
<p>为了解决这些问题，演进出了 Reactor 多线程模型，下面我们一起学习下 Reactor 多线程模型。 Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作，它的原理图如下：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419111438562.png" alt="image-20200419111438562"></p>
<p>Reactor 多线程模型的特点：</p>
<ol>
<li>有专门一个 NIO 线程 Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求；</li>
<li>网络 IO 操作读、写等由一个 NIO 线程池负责，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N 个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送；</li>
<li>1 个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，防止发生并发操作问题。 在绝大多数场景下，Reactor 多线程模型都可以满足性能需求；但是，在极特殊应用场景中，一个 NIO 线程负责监听 和处理所有的客户端连接可能会存在性能问题。例如百万客户端并发连接，或者服务端需要对客户端的握手消息进行安全认证，认证本身非常损耗性能。在这类场景下，单独一个 Acceptor 线程可能会存在性能不足问题，为了解决性能问题，产生了第三种 Reactor 线程模型主从 Reactor 多线程模型。 </li>
</ol>
<p>主从 Reactor 线程模型的特点是：服务端用于接收客户端连接的不再是个 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池。Acceptor 接收到客户端 TCP 连接请求处理完成后（可能包含接入认证等），将新创建的 SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责 SocketChannel 的读写和编解码工作。Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作。</p>
<p>它的线程模型如下图所示：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419112016011.png" alt="image-20200419112016011"></p>
<p>利用主从 NIO 线程模型，可以解决 1 个服务端监听线程无法有效处理所有客户端连接的性能不足问题。因此，在 Netty 的官方 demo 中，推荐使用该线程模型。 事实上，Netty 的线程模型并非固定不变，通过在启动辅助类中创建不同的 EventLoopGroup 实例并通过适当的参数配置，就可以支持上述三种 Reactor 线程模型。正是因为 Netty 对 Reactor 线程模型的支持提供了灵活的定制能力， 所以可以满足不同业务场景的性能诉求。</p>
<h3 id="5-无锁化的串行设计理念"><a href="#5-无锁化的串行设计理念" class="headerlink" title="5. 无锁化的串行设计理念"></a>5. 无锁化的串行设计理念</h3><p>在大多数场景下，并行多线程处理可以提升系统的并发性能。但是，如果对于共享资源的并发访问处理不当，会带来 严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。 </p>
<p>为了尽可能提升性能，Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动 多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。 Netty 的串行化设计工作原理图如下：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419112111871.png" alt="image-20200419112111871"></p>
<p>Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的 fireChannelRead(Object msg)，只要用户不主 动切换线程，一直会由 NioEventLoop 调用到用户的 Handler，期间不进行线程切换，这种串行化处理方式避免了多线 程操作导致的锁的竞争，从性能角度看是最优的。</p>
<h3 id="6-高效的并发编程"><a href="#6-高效的并发编程" class="headerlink" title="6. 高效的并发编程"></a>6. 高效的并发编程</h3><p>Netty 的高效并发编程主要体现在如下几点： </p>
<ol>
<li>volatile 的大量、正确使用; </li>
<li>CAS 和原子类的广泛使用；</li>
<li>线程安全容器的使用；</li>
<li>通过读写锁提升并发性能。</li>
</ol>
<h3 id="7-高性能的序列化框架"><a href="#7-高性能的序列化框架" class="headerlink" title="7. 高性能的序列化框架"></a>7. 高性能的序列化框架</h3><p>影响序列化性能的关键因素总结如下： </p>
<ol>
<li>序列化后的码流大小（网络带宽的占用）；</li>
<li>序列化&amp;反序列化的性能（CPU 资源占用）；</li>
<li>是否支持跨语言（异构系统的对接和开发语言切换）。 </li>
</ol>
<p>Netty 默认提供了对 Google Protobuf 的支持，通过扩展 Netty 的编解码接口，用户可以实现其它的高性能序列化框架， 例如 Thrift 的压缩二进制编解码框架。下面我们一起看下不同序列化&amp;反序列化框架序列化后的字节数组对比：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419112524763.png" alt="image-20200419112524763"></p>
<p>从上图可以看出，Protobuf 序列化后的码流只有 Java 序列化的 1/4 左右。正是由于 Java 原生序列化性能表现太差， 才催生出了各种高性能的开源序列化技术和框架（性能差只是其中的一个原因，还有跨语言、IDL 定义等其它因素）。</p>
<h3 id="8-灵活的-TCP-参数配置能力"><a href="#8-灵活的-TCP-参数配置能力" class="headerlink" title="8. 灵活的 TCP 参数配置能力"></a>8. 灵活的 TCP 参数配置能力</h3><p>合理设置 TCP 参数在某些场景下对于性能的提升可以起到显著的效果，例如 SO_RCVBUF 和 SO_SNDBUF。如果设置 不当，对性能的影响是非常大的。</p>
<p>下面我们总结下对性能影响比较大的几个配置项：</p>
<ol>
<li>SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K；</li>
<li>SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；</li>
<li>软中断：如果 Linux 内核版本支持 RPS（2.6.35 以上版本），开启 RPS 后可以实现软中断，提升网络吞吐量。RPS 根据数据包的源地址，目的地址以及目的和源端口，计算出一个 hash 值，然后根据这个 hash 值来选择软中断运行的 cpu，从上层来看，也就是说将每个连接和 cpu 绑定，并通过这个 hash 值，来均衡软中断在多个 cpu 上，提升网络并行处理性能。 </li>
</ol>
<p>Netty 在启动辅助类中可以灵活的配置 TCP 参数，满足不同的用户场景。相关配置接口定义如下：</p>
<p><img src="C:%5CUsers%5CLiDaShuang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200419112547547.png" alt="image-20200419112547547"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>LiDaShuang</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://lidashuang.com/2020/04/19/Netty%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93/">http://lidashuang.com/2020/04/19/Netty%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/04/19/%E6%8F%AD%E5%BC%80%20BootStrap%20%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/">揭开 BootStrap 的神秘面纱</a>
            
            
            <a class="next" rel="next" href="/2020/04/17/RPC%20Netty/">RPC Netty</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© LiDaShuang | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
